#!/usr/bin/env bash
set -euo pipefail

# --- Configuration ---
OWNER="CoriyonArrington" # Your GitHub username/org
REPO="nextjs-with-supabase" # Your GitHub repository name
API_BASE_URL="https://api.github.com"
# Label used to identify issues that should be included in the roadmap
ROADMAP_LABEL="Roadmap" # Updated to match the label you created
# --- End Configuration ---

# --- GitHub Token Handling ---
# Ensure we have a token
# Use GITHUB_TOKEN env var if set, otherwise try gh cli, otherwise error.
if [ -z "${GITHUB_TOKEN:-}" ]; then
  # Try getting token from gh cli
  GITHUB_TOKEN="$(gh auth token 2>/dev/null || true)" 
  if [ -z "$GITHUB_TOKEN" ]; then
    echo "❌ ERROR: No GITHUB_TOKEN found." >&2
    echo "  Please ensure the GitHub CLI (gh) is installed and authenticated ('gh auth login')," >&2
    echo "  or export your GitHub token: 'export GITHUB_TOKEN=your_personal_access_token'" >&2
    exit 1
  fi
fi

# --- File Paths ---
TIMESTAMP=$(date +'%Y-%m-%d-%H%M%S')
OUTPUT_DIR="reports/roadmap" # Output directory relative to project root
OUTPUT_FILENAME="roadmap-${TIMESTAMP}.md" # Timestamped output file
OUTPUT_FILE="${OUTPUT_DIR}/${OUTPUT_FILENAME}" # Full path to output file
SYMLINK_NAME="ROADMAP.md" # Symlink in project root pointing to the latest roadmap

# --- Script Logic ---
echo "🚀 Generating Roadmap..."

# Ensure output directory exists
mkdir -p "$OUTPUT_DIR"

# Remove any older roadmap files in the output directory to keep it clean
# Use find for safer deletion, especially if filenames could have spaces (unlikely here)
find "$OUTPUT_DIR" -name 'roadmap-*.md' -type f -delete
echo "🧹 Cleaned old roadmap files from ${OUTPUT_DIR}."

# Write header to the new roadmap file
{
  echo "# Project Roadmap"
  echo
  echo "Generated: $(date)" # Use a more readable date format
  echo
  echo "> **Note:** This file is auto-generated by the \`generate-roadmap.sh\` script based on issues labeled '${ROADMAP_LABEL}' in the [${OWNER}/${REPO}](https://github.com/${OWNER}/${REPO}/issues) repository. Do not edit directly."
  echo
} > "$OUTPUT_FILE"

echo " fetching issues labeled '${ROADMAP_LABEL}' from GitHub..."

# Fetch issues using GitHub API, parse with jq
# Fetches up to 100 issues (default per_page), add &page=X if more needed
if ! curl -s -f -H "Authorization: Bearer $GITHUB_TOKEN" \
     -H "Accept: application/vnd.github.v3+json" \
     "${API_BASE_URL}/repos/${OWNER}/${REPO}/issues?state=all&labels=${ROADMAP_LABEL}&per_page=100" \
| jq -r --arg roadmap_label "$ROADMAP_LABEL" '
    # Ensure input is an array, provide empty array on error (e.g., bad token, repo not found)
    if type == "array" then . else [] end
    
    # Sort by issue number for consistent ordering
    | sort_by(.number) 
    
    # Process each issue object in the array
    | .[] 
    |
    # Determine status based on state and assignees (Simplified logic)
    ( if .state == "closed" then "✅ Completed"
      # Removed the .pull_request check for now to simplify parsing
      elif (.assignees | length > 0) then "🚧 In Progress" 
      else "⏳ Pending" 
      end ) as $status
    |
    # Extract the first "Phase: X" label found, default to "Phase ?"
    ( .labels | map(.name | select(test("^Phase: "))) | .[0] // "Phase ?" ) as $phase
    |
    # Extract the first "Priority: X" label found, default to empty string
    ( .labels | map(.name | select(test("^Priority: "))) | .[0] // "" ) as $priority
    |
    # Format the output line as Markdown list item
    "- [" + $status + "] **" + $phase + "**: [" + .title + "](" + .html_url + ")" 
    # Append priority only if it was found
    + ( if $priority != "" then " (`" + $priority + "`)" else "" end )
  ' >> "$OUTPUT_FILE"; then
  echo "❌ ERROR: Failed to fetch or process issues from GitHub." >&2
  echo "   Check repository name ('${REPO}'), label ('${ROADMAP_LABEL}'), and GitHub token permissions." >&2
  # Optional: remove the partially created file on error
  # rm -f "$OUTPUT_FILE" 
  exit 1
fi

# Check if any issues were actually added (jq output might be empty)
# Count lines added after the header (simple check)
# Header lines: 5 (adjust if header changes)
ADDED_LINES=$(($(wc -l < "$OUTPUT_FILE") - 5)) 
if [[ $ADDED_LINES -le 0 ]]; then
  echo "⚠️ WARNING: No issues found with the label '${ROADMAP_LABEL}' or failed to parse."
  echo "- [ ] _No roadmap issues found with label '${ROADMAP_LABEL}'._" >> "$OUTPUT_FILE"
fi

# Refresh symlink in the project root directory
# Use relative path for portability
ln -sf "${OUTPUT_DIR#./}/${OUTPUT_FILENAME}" "$SYMLINK_NAME" 
# Explanation: 
# -sf forces link creation, overwriting old link
# ${OUTPUT_DIR#./} removes leading ./ if present for cleaner relative path
# $OUTPUT_FILENAME is the timestamped file
# $SYMLINK_NAME is ROADMAP.md in the root

echo "✅ Roadmap generated: ${OUTPUT_FILE}"
echo "🔗 Symlink updated: ${SYMLINK_NAME} -> ${OUTPUT_DIR}/${OUTPUT_FILENAME}"
